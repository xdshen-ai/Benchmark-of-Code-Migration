{"solution_function": "import pandas as pd\ndef check_floating_and_numeric(indices):\n    return [(pd.Index.is_floating(idx), pd.Index.is_numeric(idx)) for idx in indices]"}
{"solution_function": "import pandas as pd\n\ndef validate_data(df):\n    integer_columns = [col for col in df.columns if pd.api.types.is_integer_dtype(df[col])]\n    object_columns = [col for col in df.columns if pd.api.types.is_object_dtype(df[col])]\n    integer_sum = df[integer_columns].sum().sum()\n    unique_objects = sum(df[obj_col].nunique() for obj_col in object_columns)\n    return integer_sum, unique_objects"}
{"solution_function": "import pandas\n\ndef process_and_filter(data):\n    if pandas.api.types.is_integer_dtype(data):\n        return data[data % 2 == 0].sum()\n    elif pandas.api.types.is_object_dtype(data):\n        return data.str.len().max()\n    else:\n        return None"}
{"solution_function": "def interpolate_and_check_numeric(data):\n    df = pd.DataFrame(data)\n    df = df.bfill()\n    numeric_cols = [col for col in df.columns if pd.api.types.is_any_real_numeric_dtype(df[col])]\n    numeric_data = df[numeric_cols]\n    return numeric_data.mean().to_dict()"}
{"solution_function": "import pandas\n\ndef transform_and_validate_data(df, column_name):\n    data_numeric = pandas.api.types.is_any_real_numeric_dtype(df[column_name])\n    if not data_numeric:\n        raise ValueError(\"Column data must be numeric\")\n    df[column_name].bfill(inplace=True)\n    return df"}
{"solution_function": "import pandas as pd\n\ndef analyze_numeric_data(data):\n    float_columns = [col for col in data.columns if pd.api.types.is_float_dtype(data[col])]\n    real_numeric_columns = [col for col in data.columns if pd.api.types.is_any_real_numeric_dtype(data[col])]\n    return {'float_columns': float_columns, 'real_numeric_columns': real_numeric_columns}\n"}
{"solution_function": "import pandas as pd\n\ndef count_floats_and_bools(data):\n    float_count = 0\n    bool_count = 0\n    for column in data.columns:\n        if pd.api.types.is_float_dtype(data[column]):\n            float_count += 1\n        elif pd.api.types.is_bool_dtype(data[column]):\n            bool_count += 1\n    return {'float_count': float_count, 'bool_count': bool_count}"}
{"solution_function": "import tensorflow as tf\n\ndef complex_tensor_operations(input_tensor):\n    erfc_result = tf.erfc(input_tensor)\n    zeta_result = tf.zeta(input_tensor, input_tensor + 1)\n    floormod_result = tf.floormod(input_tensor, tf.constant(3.0))\n    combined_result = erfc_result + zeta_result - floormod_result\n    with tf.Session() as sess:\n        result = sess.run(combined_result)\n    return result\n"}
{"solution_function": "import tensorflow as tf\n\ndef compute_complex_metric(a, b, c, q):\n    intermediate1 = tf.erfc(a)\n    intermediate2 = tf.zeta(b, q)\n    intermediate3 = tf.floormod(c, 2)\n    combined = intermediate1 + intermediate2 - intermediate3\n    with tf.Session() as sess:\n        result = sess.run(combined)\n    return result\n"}
{"solution_function": "def segment_product_with_ceiling(data, segment_ids):\n    segment_product = tf.segment_prod(data, segment_ids)\n    ceiling_result = tf.ceil(segment_product)\n    with tf.Session() as sess:\n        segment_product_val, ceiling_result_val = sess.run([segment_product, ceiling_result])\n    return ceiling_result_val"}
{"solution_function": "import tensorflow as tf\n\ndef segment_ceil_prod(data, segment_ids):\n    ceiled_data = tf.ceil(data)\n    result = tf.segment_prod(ceiled_data, segment_ids)\n    with tf.Session() as sess:\n        sess.run(tf.global_variables_initializer())\n        output = sess.run(result)\n    return output"}
{"solution_function": "import tensorflow as tf\n\ndef compute_cumulative_beta_product(tensor_list):\n    log_betas = [tf.lbeta(x) for x in tensor_list]\n    cumprod_log_betas = tf.cumprod(log_betas, axis=0)\n    with tf.Session() as sess:\n        sess.run(tf.global_variables_initializer())\n        return sess.run(cumprod_log_betas)\n"}
{"solution_function": "import tensorflow as tf\n\ndef process_and_combine(data, segment_ids):\n    segmented_sum = tf.segment_sum(data, segment_ids)\n    sqrt_segmented_sum = tf.sqrt(segmented_sum)\n    rsqrt_segmented_sum = tf.rsqrt(sqrt_segmented_sum)\n    rounded_result = tf.ceil(rsqrt_segmented_sum)\n    with tf.Session() as sess:\n        result = sess.run(rounded_result)\n    return result\n"}
{"solution_function": "import tensorflow as tf\n\ndef compute_custom_metric(data, segment_ids):\n    segment_sums = tf.segment_sum(data, segment_ids)\n    ceil_values = tf.ceil(segment_sums)\n    rsqrt_values = tf.rsqrt(ceil_values)\n    with tf.Session() as sess:\n        sess.run(tf.global_variables_initializer())\n        result = sess.run(rsqrt_values)\n    return result\n"}
{"solution_function": "import tensorflow as tf\ndef compute_accuracy_and_modulo(true_labels, model_predictions, x, y, threshold=0.5):\n    predictions_binary = tf.cast(model_predictions > threshold, tf.float32)\n    accuracy, update_op = tf.metrics.accuracy(labels=true_labels, predictions=predictions_binary)\n    modulo_result = tf.floormod(x, y)\n    with tf.Session() as sess:\n        sess.run(tf.local_variables_initializer())\n        accuracy_value = sess.run(update_op)\n        modulo_value = sess.run(modulo_result)\n    return (accuracy_value, modulo_value)"}
{"solution_function": "import tensorflow as tf\n\ndef compute_accuracy_with_remainder(true_labels, model_predictions, divisor, threshold=0.5):\n    predictions_binary = tf.cast(model_predictions > threshold, tf.float32)\n    accuracy, update_op = tf.metrics.accuracy(labels=true_labels, predictions=predictions_binary)\n    remainders = tf.floormod(model_predictions, divisor)\n    with tf.Session() as sess:\n        sess.run(tf.local_variables_initializer())\n        accuracy_value = sess.run(update_op)\n        remainders_value = sess.run(remainders)\n    return accuracy_value, remainders_value\n"}
{"solution_function": "import tensorflow as tf\ndef compute_modified_error_function(input_tensor):\n    real_part = tf.real(input_tensor)\n    reciprocal_real = tf.reciprocal(real_part)\n    error_function_result = tf.erf(reciprocal_real)\n    with tf.Session() as sess:\n        result = sess.run(error_function_result)\n    return result"}
{"solution_function": "import tensorflow as tf\n\ndef complex_number_operations_and_analysis(complex_numbers):\n    real_parts = tf.real(complex_numbers)\n    reciprocal_real_parts = tf.reciprocal(real_parts)\n    erf_reciprocal_real_parts = tf.erf(reciprocal_real_parts)\n    with tf.Session() as sess:\n        sess.run(tf.global_variables_initializer())\n        result = sess.run(erf_reciprocal_real_parts)\n    return result\n"}
{"solution_function": "import tensorflow as tf\n\ndef process_and_segment_max(data, segment_ids):\n    ceil_data = tf.ceil(data)\n    erf_data = tf.erf(ceil_data)\n    segment_maxima = tf.segment_max(erf_data, segment_ids)\n    with tf.Session() as sess:\n        result = sess.run(segment_maxima)\n    return result\n"}
{"solution_function": "import tensorflow as tf\n\ndef compute_segment_max_and_rounded_erf(data, segment_ids):\n    segmented_max = tf.segment_max(data, segment_ids)\n    erf_values = tf.erf(segmented_max)\n    rounded_erf_values = tf.ceil(erf_values)\n    with tf.Session() as sess:\n        result = sess.run(rounded_erf_values)\n    return result\n"}
{"solution_function": "import tensorflow as tf\ndef calculate_complex_value(arr1, arr2, arr3):\n    max_indices = tf.math.argmax(arr1, axis=0, output_type=tf.dtypes.int64)\n    accumulated_sum = tf.math.accumulate_n([arr1, arr2, arr3])\n    error_function_values = tf.math.erf(accumulated_sum)\n    result = tf.gather(error_function_values, max_indices)\n    return result.numpy().tolist()"}
{"solution_function": "import tensorflow as tf\n\ndef compute_nonzero_division(matrix_1, matrix_2):\n    nonzero_count_1 = tf.math.count_nonzero(matrix_1, axis=1, dtype=tf.dtypes.int64)\n    nonzero_count_2 = tf.math.count_nonzero(matrix_2, axis=1, dtype=tf.dtypes.int64)\n    division_result = tf.math.divide(nonzero_count_1, nonzero_count_2)\n    return division_result.numpy()"}
{"solution_function": "import tensorflow as tf\n\ndef compute_complex_expression(arr):\n    tensor_arr = tf.convert_to_tensor(arr, dtype=tf.float32)\n    erf_values = tf.math.erf(tensor_arr)\n    abs_values = tf.math.abs(erf_values)\n    result = tf.reduce_mean(abs_values)\n    return result.numpy()"}
{"solution_function": "import tensorflow as tf\n\ndef compute_composite_function(matrix):\n    acos_matrix = tf.math.acos(matrix)\n    abs_acos_matrix = tf.math.abs(acos_matrix)\n    result = tf.math.add_n([abs_acos_matrix, matrix])\n    return result.numpy()"}
{"solution_function": "import tensorflow as tf\n\ndef find_normalized_max_indices(matrix):\n    row_sums = tf.reduce_sum(matrix, axis=1)\n    normalized_matrix = tf.math.divide(matrix, tf.expand_dims(row_sums, axis=1))\n    max_indices = tf.math.argmax(normalized_matrix, axis=1, output_type=tf.dtypes.int32)\n    return max_indices.numpy()"}
{"solution_function": "import tensorflow as tf\n\ndef compute_transformed_ratio(arr1, arr2, power):\n    ratio_tensor = tf.math.divide(arr1, arr2)\n    transformed_tensor = tf.math.pow(ratio_tensor, power)\n    return transformed_tensor.numpy()"}
{"solution_function": "import tensorflow as tf\n\ndef calculate_accuracy_of_absolute_differences(list1, list2):\n    abs_diff = tf.math.abs(tf.subtract(list1, list2))\n    binary_diff = tf.cast(tf.equal(abs_diff, 0), tf.int32)\n    accuracy_metric = tf.keras.metrics.Accuracy()\n    accuracy_metric.update_state(tf.ones_like(binary_diff), binary_diff)\n    return accuracy_metric.result().numpy()"}
{"solution_function": "def transform_and_evaluate(matrix):\n    abs_matrix = tf.math.abs(matrix)\n    tanh_matrix = tf.math.tanh(abs_matrix)\n    return tf.reduce_sum(tanh_matrix).numpy()"}
{"solution_function": "import tensorflow as tf\n\ndef find_remainder_min_index(matrix, divisor):\n    remainder_matrix = tf.math.floormod(matrix, divisor)\n    min_indices = tf.math.argmin(remainder_matrix, axis=1)\n    return min_indices.numpy().tolist()"}
{"solution_function": "import tensorflow as tf\n\ndef complex_transform_and_cosine(input_list):\n    complex_numbers = [tf.complex(x, x+1) for x in input_list]\n    pow_results = [tf.math.pow(c, 2) for c in complex_numbers]\n    imag_parts = [tf.math.imag(p) for p in pow_results]\n    cosine_results = [tf.math.cos(i) for i in imag_parts]\n    return [c.numpy() for c in cosine_results]"}
{"solution_function": "import tensorflow as tf\n\ndef complex_cosine_power_sum(real_parts, imaginary_parts, powers):\n    complex_numbers = tf.complex(real_parts, imaginary_parts)\n    cosine_values = tf.math.cos(complex_numbers)\n    powered_cosines = tf.math.pow(cosine_values, powers)\n    imaginary_parts = tf.math.imag(powered_cosines)\n    return tf.reduce_sum(imaginary_parts).numpy()"}
{"solution_function": "def activation_stats(input_tensor):\n    sigmoid_output = torch.nn.functional.sigmoid(input_tensor)\n    relu_output = torch.nn.functional.relu(input_tensor)\n    max_sigmoid = torch.max(sigmoid_output)\n    min_sigmoid = torch.min(sigmoid_output)\n    max_relu = torch.max(relu_output)\n    min_relu = torch.min(relu_output)\n    return (max_sigmoid.item(), min_sigmoid.item(), max_relu.item(), min_relu.item())"}
{"solution_function": "def process_and_apply_tanh(matrix):\n    import torch\n    tensor = torch.tensor(matrix, dtype=torch.float32)\n    squared = torch.square(tensor)\n    summed = torch.sum(squared, dim=1)\n    summed_unsqueezed = summed.unsqueeze(1)\n    tanh_applied = torch.nn.functional.tanh(summed_unsqueezed)\n    return tanh_applied.tolist()"}
